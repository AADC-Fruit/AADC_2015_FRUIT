/*
clsquare - closed loop simulation system
Copyright (c) 2010-2012 Machine Learning Lab, 
Prof. Dr. Martin Riedmiller, University of Freiburg

Author: Thomas Lampe

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

   * Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
   * Neither the name of the <ORGANIZATION> nor the names of its
     contributors may be used to endorse or promote products derived
     from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
DAMAGE. 
*/

#ifndef _MIXCONTROL_H_
#define _MIXCONTROL_H_

#include "controller.h"
#include "reward.h"
#include "MixControl/operation.h"
#include "MixControl/slave.h"
#include "MixControl/action.h"
#include "utils/setdef.h"
#include <vector>

using namespace CLS;
using namespace CLS::Util;

/**
  * Provides a meta-controller that creates instances of other controller types and assigns them to
  * different dimensions of the action, thus allowing to mix various types of controllers.
  *
  * A sub-controller is added through a config entry of the form <em>controller_i = ControllerType Section</em>,
  * where \e i begins at 0 for the first controller and is numbered incrementally for additional ones.
  * Specifying the config section where the controller is defined is optional; [Controller_i] is used by default.
  *
  * In addition, it is possible to define the state that each controller receives and the action it generates.
  * The parameter \e action_dim_i sets the dimensionality of the action to a value different from the one
  * defined by the plant. Likewise, \e state_dim_i does the same for the state; \e state_assign then determines
  * which dimensions of the plant measurement should be passed on to the controller.
  *
  * The actions that are generated by the sub-controllers then have to be combined back into an action to be
  * sent to the plant, which is controlled through the parameter \e assignment. It consists of pairs of a 
  * sub-controller and action index, one for each of the plant action dimensions. For instance,
  * <em>assignment = [1 3] [0 1]</em> would use action 3 of controller 1 for the first plant action, and action 1
  * of controller 0 for the second.
  *
  * Lastly, two more parameters shape the final action:
  * \li \e multi: defines multipliers that will be applied element-wise to the composite action
  * \li \e add: defines constant values that will be added to the composite action (after the multiplication step)
  *
  * <em> (Note: the following method for specifying conditions is deprecated. For new applications, use the
  *  controller type MixControlCondition instead.) </em>
  *
  * It is also possible to use different controllers for one action dimension, with the eligible controller
  * being determined based on the current system measurement. An alternative \e i for an action \e x can
  * be specified by adding the two config entries, where \e i is the index of the alternative, starting at 0.
  * If two different alternatives would match a given state, the one with the lower number will be chosen, hence
  * they should be ordered from most specific to most general. If no alternative matches, the default controller
  * as given by \e assignment will be used.
  * \li \e action_x_i_params: provides 4 numbers that specify, in this order, the index of the controller
  *   to be used, the action index of of the controller, the multiplier and the addition constant.
  * \li \e action_x_i_condition: provides a state definition as per the SetDef syntax which describes the
  *   set of states in which the alternative will apply.
  *
  * For instance, <em>action_0_0_params = 1 3 2 0</em> and <em>action_0_0_condition = [0.5 1][]</em> would
  * use the double value of action dimension 3 of controller 1 whenever dimension 0 of the measurement is
  * betweem 0.5 and 1.
  *
  * @ingroup CONTROLLER
  * @ingroup META
  * @author Thomas Lampe
  **/
class MixControl : public Controller, public Reward {
  public:
	  bool get_action (const double* state, double* action);
	  bool init (const int observed_state_dim, const int action_dim, double deltat, const char* fname=0, const char* chapter=0);
	  void deinit ();
    void notify_episode_starts (const long episode);
    void notify_episode_stops (const double* current_observed_state);
    void notify_transition (const double* observed_state, const double* action, const double* next_observed_state, const double reward, const bool is_terminal_state, const double terminal_reward);
    void notify_command_string (const char* buf);
    bool check_initial_state (const double* initial_observed_state, const int observation_dim);

    bool init (int plant_state_dim, int measurement_dim, int observed_state_dim, int action_dim, int* expected_input_type, const char* fname, const char* chapter=0);
    double get_reward (const double *current_state_representation, const double *current_action, const double *next_state_representation);
    bool is_terminal(const double *state_representation);
    double get_terminal_reward (const double *state_representation);

	  MixControl ();
	  ~MixControl ();

  protected:
    bool _success;
    unsigned int _i, _j, _k, _state_dim;
    struct {
      double *observation;
      //double *action;
    } _tmp;
    std::vector<std::vector<MixControlAction> > _assignment;
    std::vector<MixControlSlave> _slaves;
    std::vector<int> _rewards;
    struct {
      CLS::Reward* base;
      int sdim, adim;
      int type, id;
      bool reduce;
    } _reward;
};

#endif
